(function () {
  // Utility function to create a Float64Array with optional initialization
  function gf(init) {
    const r = new Float64Array(16);
    if (init) {
      for (let i = 0; i < init.length; ++i) r[i] = init[i];
    }
    return r;
  }

  // Pack function to convert internal representation to byte array
  function pack(o, n) {
    const m = gf(), t = gf();
    for (let i = 0; i < 16; ++i) t[i] = n[i];
    carry(t);
    carry(t);
    carry(t);
    for (let j = 0; j < 2; ++j) {
      m[0] = t[0] - 65517;
      for (let i = 1; i < 15; ++i) {
        m[i] = t[i] - 65535 - ((m[i - 1] >> 16) & 1);
        m[i - 1] &= 65535;
      }
      m[15] = t[15] - 32767 - ((m[14] >> 16) & 1);
      const b = (m[15] >> 16) & 1;
      m[14] &= 65535;
      cswap(t, m, 1 - b);
    }
    for (let i = 0; i < 16; ++i) {
      o[2 * i] = t[i] & 255;
      o[2 * i + 1] = t[i] >> 8;
    }
  }

  // Carry propagation to ensure values fit within 16 bits
  function carry(o) {
    for (let i = 0; i < 16; ++i) {
      o[(i + 1) % 16] += (i < 15 ? 1 : 38) * Math.floor(o[i] / 65536);
      o[i] &= 65535;
    }
  }

  // Conditional swap based on a bit
  function cswap(p, q, b) {
    const c = ~(b - 1);
    for (let i = 0; i < 16; ++i) {
      const t = c & (p[i] ^ q[i]);
      p[i] ^= t;
      q[i] ^= t;
    }
  }

  // Arithmetic operations
  function add(o, a, b) {
    for (let i = 0; i < 16; ++i) o[i] = a[i] + b[i] | 0;
  }

  function subtract(o, a, b) {
    for (let i = 0; i < 16; ++i) o[i] = a[i] - b[i] | 0;
  }

  function multmod(o, a, b) {
    const t = new Float64Array(31);
    for (let i = 0; i < 16; ++i) {
      for (let j = 0; j < 16; ++j) t[i + j] += a[i] * b[j];
    }
    for (let i = 0; i < 15; ++i) t[i] += 38 * t[i + 16];
    for (let i = 0; i < 16; ++i) o[i] = t[i];
    carry(o);
    carry(o);
  }

  // Modular inversion
  function invert(o, i) {
    const c = gf();
    for (let a = 0; a < 16; ++a) c[a] = i[a];
    for (let a = 253; a >= 0; --a) {
      multmod(c, c, c);
      if (a !== 2 && a !== 4) multmod(c, c, i);
    }
    for (let a = 0; a < 16; ++a) o[a] = c[a];
  }

  // Clamp function to ensure private key validity
  function clamp(z) {
    z[31] = (z[31] & 127) | 64;
    z[0] &= 248;
  }

  // Generate public key from private key
  function generatePublicKey(privateKey) {
    const z = new Uint8Array(32);
    const a = gf([1]), b = gf([9]), c = gf(), d = gf([1]), e = gf(), f = gf();
    const _121665 = gf([56129, 1]), _9 = gf([9]);
    for (let i = 0; i < 32; ++i) z[i] = privateKey[i];
    clamp(z);
    for (let i = 254; i >= 0; --i) {
      const r = (z[i >>> 3] >>> (i & 7)) & 1;
      cswap(a, b, r);
      cswap(c, d, r);
      add(e, a, c);
      subtract(a, a, c);
      add(c, b, d);
      subtract(b, b, d);
      multmod(d, e, e);
      multmod(f, a, a);
      multmod(a, c, a);
      multmod(c, b, e);
      add(e, a, c);
      subtract(a, a, c);
      multmod(b, a, a);
      subtract(c, d, f);
      multmod(a, c, _121665);
      add(a, a, d);
      multmod(c, c, a);
      multmod(a, d, f);
      multmod(d, b, _9);
      multmod(b, e, e);
      cswap(a, b, r);
      cswap(c, d, r);
    }
    invert(c, c);
    multmod(a, a, c);
    pack(z, a);
    return z;
  }

  // Generate a random preshared key
  function generatePresharedKey() {
    const privateKey = new Uint8Array(32);
    window.crypto.getRandomValues(privateKey);
    return privateKey;
  }

  // Generate a private key
  function generatePrivateKey() {
    const privateKey = generatePresharedKey();
    clamp(privateKey);
    return privateKey;
  }

  // Base64 encoding and decoding
  function encodeBase64(dest, src) {
    const input = Uint8Array.from([
      (src[0] >> 2) & 63,
      ((src[0] << 4) | (src[1] >> 4)) & 63,
      ((src[1] << 2) | (src[2] >> 6)) & 63,
      src[2] & 63,
    ]);
    for (let i = 0; i < 4; ++i) {
      dest[i] =
        input[i] +
        65 +
        ((25 - input[i]) >> 8 & 6) -
        ((51 - input[i]) >> 8 & 75) -
        ((61 - input[i]) >> 8 & 15) +
        ((62 - input[i]) >> 8 & 3);
    }
  }

  function keyToBase64(key) {
    const base64 = new Uint8Array(44);
    for (let i = 0; i < 32 / 3; ++i) {
      encodeBase64(base64.subarray(i * 4), key.subarray(i * 3));
    }
    encodeBase64(base64.subarray((32 / 3) * 4), Uint8Array.from([key[32 / 3 * 3], key[32 / 3 * 3 + 1], 0]));
    base64[43] = 61; // '=' padding
    return String.fromCharCode.apply(null, base64);
  }

  function base64ToKey(base64) {
    const binaryString = window.atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return new Uint8Array(bytes.buffer);
  }

  // Utility functions for ZIP file creation
  function putU32(b, n) {
    b.push(n & 255, (n >>> 8) & 255, (n >>> 16) & 255, (n >>> 24) & 255);
  }

  function putU16(b, n) {
    b.push(n & 255, (n >>> 8) & 255);
  }

  function putBytes(b, a) {
    for (let i = 0; i < a.length; ++i) b.push(a[i] & 255);
  }

  function encodeString(s) {
    const utf8 = unescape(encodeURIComponent(s));
    const b = new Uint8Array(utf8.length);
    for (let i = 0; i < utf8.length; ++i) b[i] = utf8.charCodeAt(i);
    return b;
  }

  function crc32(b) {
    if (!crc32.table) {
      crc32.table = [];
      for (let n = 0; n < 256; ++n) {
        let c = n;
        for (let k = 0; k < 8; ++k) {
          c = c & 1 ? 3988292384 ^ (c >>> 1) : c >>> 1;
        }
        crc32.table[n] = c;
      }
    }
    let crc = -1;
    for (let i = 0; i < b.length; ++i) {
      crc = (crc >>> 8) ^ crc32.table[(crc ^ b[i]) & 255];
    }
    return (crc ^ -1) >>> 0;
  }

  function createZipFile(files) {
    const b = [];
    const cd = [];
    let offset = 0;
    for (const file of files) {
      const name = encodeString(file.filename);
      const contents = encodeString(file.content);
      const crc = crc32(contents);
      putU32(b, 67324752); // Local file header signature
      putU16(b, 20); // Version needed to extract
      putU16(b, 0); // General purpose bit flag
      putU16(b, 0); // Compression method
      putU16(b, 0); // File last modification time
      putU16(b, 0); // File last modification date
      putU32(b, crc); // CRC-32
      putU32(b, contents.length); // Compressed size
      putU32(b, contents.length); // Uncompressed size
      putU16(b, name.length); // File name length
      putU16(b, 0); // Extra field length
      putBytes(b, name); // File name
      putBytes(b, contents); // File content
      putU32(cd, 33639248); // Central directory file header signature
      putU16(cd, 0); // Version made by
      putU16(cd, 20); // Version needed to extract
      putU16(cd, 0); // General purpose bit flag
      putU16(cd, 0); // Compression method
      putU16(cd, 0); // File last modification time
      putU16(cd, 0); // File last modification date
      putU32(cd, crc); // CRC-32
      putU32(cd, contents.length); // Compressed size
      putU32(cd, contents.length); // Uncompressed size
      putU16(cd, name.length); // File name length
      putU16(cd, 0); // Extra field length
      putU16(cd, 0); // File comment length
      putU16(cd, 0); // Disk number start
      putU16(cd, 0); // Internal file attributes
      putU32(cd, 32); // External file attributes
      putU32(cd, offset); // Relative offset of local header
      putBytes(cd, name); // File name
      offset += 30 + contents.length + name.length;
    }
    putBytes(b, cd); // Central directory
    putU32(b, 101010256); // End of central directory signature
    putU16(b, 0); // Number of this disk
    putU16(b, 0); // Disk where central directory starts
    putU16(b, files.length); // Number of central directory records on this disk
    putU16(b, files.length); // Total number of central directory records
    putU32(b, cd.length); // Size of central directory
    putU32(b, offset); // Offset of start of central directory
    putU16(b, 0); // Comment length
    return Uint8Array.from(b);
  }

  // Expose WireGuard functions
  window.wireguard = {
    generateKeypair() {
      const privateKey = generatePrivateKey();
      const publicKey = generatePublicKey(privateKey);
      const presharedKey = generatePresharedKey();
      return {
        publicKey: keyToBase64(publicKey),
        privateKey: keyToBase64(privateKey),
        presharedKey: keyToBase64(presharedKey),
      };
    },
    generatePublicKey(privateKey) {
      privateKey = base64ToKey(privateKey);
      return keyToBase64(generatePublicKey(privateKey));
    },
    generateZipFiles(res) {
      const files = res.peers;
      const zipFile = createZipFile(files);
      const blob = new Blob([zipFile], { type: "application/zip" });
      const a = document.createElement("a");
      a.download = res.filename;
      a.href = URL.createObjectURL(blob);
      a.style.display = "none";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    },
  };
})();